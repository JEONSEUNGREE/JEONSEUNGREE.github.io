{"pages":[],"posts":[{"title":"Day59_Vue_Slot","text":"59일차 수업","link":"/2021/08/04/Day59-Vue-Slot/"},{"title":"Day60_Vuetify_dialog","text":"60일차 수업 vuetify 든 어떤 기능을 쓸때 api보고 코드 복붙하면 편하지만 어느정도 동작은 알고있어야된다.","link":"/2021/08/03/Day60-Vuetify-Dialog/"},{"title":"AsyncVsDefer","text":"Async Vs Defer 비동기가 필요한 이유 html을 브라우저 읽을때 코드를 읽다 sciprt를 만나면 서버에서 다운받고 읽게된다. 이 방식이면 스크립트가 클수록 사용자가 기다리는 시간이 발생한다. 이 비동기 적용을 하지않는경우 스크립트의 위치가 head에있다면 먼저 script를 받기때문에 html 코드가 보이지않게되고 반대로 body에있다면 html은 어느정도읽히지만 script에 의존적이라면 html이 보여도 이상하게 나올수있다. 따라서 비동기적으로 처리가 필요하다. Async script 에 asyn src=\"\" 이런식으로asyn을 넣어주면 비동기적 처리를 실행하게된다. 장점 : 병렬 처리로 처리시간 감소 단점 : js에서 queryselect등의 작동이 불가해질수있다. 다운받아지는 시점에따라 기능이 어느정도 될지 예상 하기 힘듬 defer script defer src=\"\" 식으로 선언하고 html을 parsing 하는 과정에 병렬로 script를 다운받고 다 받아지면 실행하게 된다. 또한 순서에있이서도 차이가 있는데async의 경우 1,2,3 script 순서로 의존적이라하면 먼저 받아진 순서가 달라서 실행과정에서 꼬일수있지만defer같은경우는 순서에따라서 받아지고 순서에따라 실행됨 오늘 vue에서도 router의 모든 컴포넌트에 적용하니까 정말 체감이 많이된다.","link":"/2021/08/01/AsyncVsDefer/"},{"title":"Day62-JPA-Save","text":"61일차 수업![Vue(/review_img/62Day/2.PNG) JPA는 편하고 좋은데 코드 쓸게 없어서 허전하다.JDBCTEMPLATE으로 구성할떄보다 확실히 코드는 간결하다.","link":"/2021/08/04/Day62-JPA-Save/"},{"title":"Day61-vuetify-table","text":"61일차 수업 Vuetify는 다 공식문서에 기능을 보고 구현하는 것뿐이다.Vuetify 기능을 설정부터 build 까지 정리해서, 수업은 설명보다 기능 코드만 정리하고자세한 구조는 따로 정리하는게 나을듯하다.","link":"/2021/08/04/Day61-Vuetify-Table/"},{"title":"첫글","text":"공부가 끝이없어 지나치게 많아","link":"/2021/07/30/First-Content/"},{"title":"JS많이 쓰는 문법위주로 정리","text":"문법대해서 필요한 부분만 빠르게 정리해봤다. Vanilla JS서 주 사용 (쓸일은 없겠지만)‘use strict’ : 최상단에 추가해 정의되지않은 변수, 상수의 오류를 보여줌 블럭: 블럭으로 지역변수 느낌으로 선언 가능: {} 블럭 밖에 선언은 global 선언 말그대로 메모리에 위치해있음 필요할때만 사용변수 var VS let의 차이에서 var가 블럭안에 있음에도 블럭밖에서 잡힌다. (ES6 이후 let 지원) var VS let 호이스팅 여부 (선언하기전에 사용) let의 경우는 오류가 나오지만 var의 경우는 undefined로 나옴 또한 {}을 무시하기때문에 외부에서 사용 가능 global 선언이 되버린다. 그래서 let을 사용해야한다. JS는 data type 없음 number로 메모리 할당여부를 고려하지않는다. (자바나 C와 다르게 고려할 필요가 없음) first-class function 이말은 function 데이터 타입처럼 변수에 할당이 가능 즉 function(function) 이런식으로 자바에서 매개변수로 메서드를 받지못했었는데 JS는 가능하다. 또한 return 타입으로 function도 가능하다. `(백틱): String + value 우리가 흔히 String + data = stringdata 이런식으로 사용을많이하는데 JS에서는 template literals라고 백틱을 통해 `string ${data}`= stringdata 이런식으로 사용가능하다. (space도 다 자동 인식) type of : 데이터 타입 알림 Symbol: 고유 식별자로 사용가능 같은 Symbol 만들기 Symbol.for('') Symbol출력 Symbol.description을 사용해서 출력 (참고로 인스턴스 주소값을 가지고있어서 symbol의 이름이 XX라고해서 String XX와는 절대 같을수 없다.) String에서 ' 표시 consolelog(\"somting's stuff\") 이러면 somthing 이렇게만 나온다 consolelog(\"somting\\'s stuff\") 이런식으로 해야지 정상출력 또한 자바처럼 \\n로 줄바꿈 가능 equality stirng 5 === number 5 = > false string 5 == number 5 => true 매개변수 디폴트값 설정 여태 이런식으로 코드를 구성했는데 function showMessage(message, from) { if(from === undefined) { from = \"unknown\"; } } 아래 문법을 사용하면 default 값을 설정할수있다. function showMessage(message, from = \"unknown\") { 이렇게 하면 = 뒤에 값이 디폴트 값이됨 ...: ...args 배열형태로 전달 Arrow functioin 자바의 람다와같이 익명 function (reuturn 생략 function, name 생략가능) (자바에서는 매개변수있으면 return 생략안됐음) ex) cont somthing = () =&gt; console.log(‘todo’);const add = (a,b) =&gt; a+b 블록({})을 사용할경우에는 return을 사용한다.const somthing = (a,b) =&gt; { return somtihngtodo} 출처는 드림코딩 by 엘리 강의를 보고 정리했다.","link":"/2021/08/01/JS%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/"},{"title":"JS클래스","text":"JS에서도 클래스가 가능하다.———–클래스 선언————constructor(name,age) {this.name = namethis.age = age}speak() {console.log(${this.name}: Hello!);}} ———–인스턴스 생성———— const ree = new PerSon(‘ree’,28);console.log(ree.name)console.log(ree.age)ree.speak(); ———–Static사용 예———— Class Article { static publisher = “coding”;}const article = new Article(); console.log(Article.publisher) Oconsole.log(article.publisher) X static : Object마다 할당X 클래스 자체에 있음 ———–상속가능(Interitance)———— class Shape {constructor(width, height, color) {this.width = width;this.heigth = height;}getArea() {return width * this.heigth;}}class Recteangle extends Shape {} const rectangle = new Rectangle( 20, 20);rectangle.getArea(); instance of 도있다. 자바랑 매우 비슷하다. 출처는 드림코딩 by 엘리 강의를 보고 정리했다.","link":"/2021/08/01/JS%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"Vuex","text":"중앙관리가 필요한이유 vue를 쓰다보면 단순히 부모와 자식이 하나씩있으면 간단하지만 같은 todo앱을 만들때도 컴포넌트를 엄청사용해서 emit,props를 쓸때와 vuex를 쓸때는 시간도 그렇고 코드를 보기도 편했다. 자식의 자식이 연달아 있다면 계속 emit을 올려주거나 props를 연달아 받게된다. 그런 문제를 해결하기 위해서 v-bind=$attr, v-on=$listener를 사용하는 방법도있지만 store를 통해 관리해주는 vuex가 있다. 구조 vuex를 보자면 vuex의 구조는 state, mutations, actions, getters, mutationstype이있다. 여기서 state는 임계영역 데이터라고 보고, mutations는 동기화를 시키는영역 component에는 딱히 비교할만한게없다. actions는 비동기영역으로 메서드라고 보면되고 getters는 computed같은 흐름으로 보면된다 또한 actions는 비동기적이기때문에 동기작업이 필요한경우는 꼭 mutations에 넣어두고 서버로부터 요청이오는데 걸리는 시간때문에actions는 비동기 처리를하면서 다른 작업을 할 수 있는것이다. 요청이 만료되었을때 비로소 mutations에 데이터 commit이 되고 데이터 접근이 가능한 순서 actions => mutations => state Actions vuex는 처음에 actions에 context라는 object를 넣는다. 그다음으로 입력받은 payload (context, payload) 구조 ---> actions로 넘길때 this.$store.dispatch (action이름, value) ---> mustations로 commit할때 this.$store.commit() addtodo( {commit, dispatch ….등이 있음}, value)context 안에는 다음과같이 commit, dispatch….같은 다양한 기능이있음actions에서 비동기가 일어나는 기능 axios , seTimeout….등 처리일단 비동기한후에 commit처리 (mutations) ex) actions: { addTodo( {commit}, value) {//또는 axios.post() 서버에 요청 작업// setTimeout으로 2초후에 commit하는 작업 등 setTimeout(function() { commit(‘ADD_TODO’, value); }, 2000); } }, payload는 많이들 데이터를 통 느낌으로 보낼때 단일 value가 아닌 배열식일때 사용한다. convention같은것 &lt;더미데이터&gt;https://jsonplaceholder.typicode.com/ 에서 더미데이터를 요청해서 받을수있다. 서버가 따로 없다면 이것을 이용해서 axios사용 axios promise가 리턴됨 (비동기)그래서 만약 axios.get(‘https://jsonplaceholder.typicode.com/users').then(res =&gt; {}이런식 요청하면요청을 보내고 promise를 리턴해준다. axios요청을 보내놓고 밑에 작업을한다. 그뒤에 res 결과가 오면 res =&gt; {}에 {}가 실행됨 ex) 다음과같이 된다면 axios.get(‘https://jsonplaceholder.typicode.com/users').then(res =&gt; { console.log(res); }) const a = 1; console.log(a); }아마 서버요청한뒤에 응답을기다리는게 아니라 바로 console.log(a)를찍고 그뒤에 res가 출력될것이다. 사용할때 아래처럼 고려하면 편하다. state를 가져올때는 computed 안에 작성하도록한다. actions를 작성할때 vuex에서 어떤 context라는 object를 넣어준다. 이것만 기억하자commit 뮤테이션방향dispatch 액션방향 actionaddtodo(context, value}context안에 commit , dispatch 등등 여러개가있다. MAPHELPER impot { mapstate } from ‘vuex’ 구조 computed: mapstate,gettersmethods: mutations, mapActions가 들어간다. 관련된 로직끼리 묶어서 파일로 뺴내는 것을 modules이라한다.코드가 적은게 아니라면 사용하는게 맞다 -출처 코지코더를 보고 정리했다 -","link":"/2021/08/01/Vuex/"}],"tags":[{"name":"Lecture","slug":"Lecture","link":"/tags/Lecture/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"Lecture","slug":"Lecture","link":"/categories/Lecture/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"vue","slug":"vue","link":"/categories/vue/"}]}