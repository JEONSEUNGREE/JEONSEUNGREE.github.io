{"pages":[],"posts":[{"title":"0_2_JPA_Yml","text":"H2 DB 사용시 yml 세팅윈도우 기준 h2 공홈 설치 실행 위와같이 실행하고 bash로 홈의 파일들을 확인하면 아래와같이 testdsl.mv.db가 생성된다. 그 다음부터는 jdbc:h2:tcp://localhost/~/testdsl 다음주소로 접속해야한다. yml 설정 (설정파일이라고 보면된다. xml, json등 과 같이 특정 구조를 가지고있는 파일) 가벼운 프로젝트용이기 때문에 ddl-auto: create (서버실행시 db 테이블을 드랍하고 새로 만든다)테스트코드용 yml도 따로 만들수있다. 테스트 폴더 내에 resource 생성후 yml 생성후 설정 jpa yml 옵션에서 show_sql: true는 하지않는게 좋다. 쿼리가 system.out.print로 출력되기때문에만약에 쿼리에 물음표(?) 보고싶다면 debug 옵션도 있지만 p6spy를 통해서도 확인가능하다.https://github.com/gavlyukovskiy/spring-boot-data-source-decorator 의 p6spy 라이브러리를 이용해서 볼수있다.","link":"/2021/09/06/0-2-JPA-Yml/"},{"title":"0_3_JPA_Domain","text":"객체지향과 관계형데이터베이스는 패러다임의 차이가 이부분을 인지하고있어야한다. ex) 차라는 클래스에서 바퀴가 있고 차.바퀴 로 들어갈수있지만 바퀴에서는 차로 갈수있는 방법이 없지만관계형데이터베이스는 id값 하나로 양쪽을 왔다갔다할수있다. 그래서 객체에서는 양방향관계에 있어서 주인을 지정하는 mappedby가있다.주인은 대부분 fk가있는 Many쪽에 존재한다.우리 생각에는 차랑 바퀴면 차쪽이 주인으로 정해야하는 것이 아닌가 라는 생각이 들지만차에 주인을 둔다면 관리하지 않는 바퀴테이블의 외래키값이 업데이트 되서 관리가 힘들다.","link":"/2021/09/06/0-3-JPA-Domain/"},{"title":"60Day-71Day-ToyProject","text":"프로젝트 시작 이틀전에 미리 vue,boot는 세팅을 해놨었다. 완료했으니깐 어느정도 버그가 있으면 잡고 공부를 좀더 하고싶다.(주말 조금쉰것 빼면 대략 12일정도 걸린것같다.) jpa를 모르니깐 정말 힘들었고 중간에 jdbc를 써야할것같은 생각도 들었다. 게시물을 반복해서 만들때야 확실히 좋지만 어떤방식으로 쿼리를 날려야하는지 jpa 기초부터 jpql를 공부하고 따로 가벼운 프로젝트를 진행해야겠다. 이번에 Git branch에 대해 먼저 공부하고 시작했는데 초반에 merge 부터 옵션적용까지 너무 삽질을 했다. 최대한 기능으로 쪼개서 feature/기능 이런식으로 commit을 했는데 아마 조금씩 더 쪼갤 필요도 있어보인다. 후반부 brannch를 보면 어느정도 이해를 해서 포맷이 유지 된것같다. 어차피 토이프로젝트를 완벽하게 할 생각은 없었다. 망쳐도 상관없으니깐 배우고 싶었다. 삽질해야 이해가 잘되서 일부러 선생님한테 일절 물어보지않았다. (따로 질문할거리를 많이 생각해놨다) 사실상 세션 처리도 알려주셔서 어려운부분은 크게 없었다. 세션이 제일 어려운 부분같았다. 프로젝트를 하면서 찾은 목표 JPA 기초 JWT JAVA 문법 다시 정리 (람다, 스트림 부분을 제대로 못들었었다.) github 코드 구경","link":"/2021/08/18/60Day-71Day-ToyProject/"},{"title":"64Day-JPA-Joincolumn","text":"61일차 수업 JPA는 따로 공부해야될것같다.","link":"/2021/08/06/64Day-JPA-Joincolumn/"},{"title":"AsyncVsDefer","text":"Async Vs Defer 비동기가 필요한 이유 html을 브라우저 읽을때 코드를 읽다 sciprt를 만나면 서버에서 다운받고 읽게된다. 이 방식이면 스크립트가 클수록 사용자가 기다리는 시간이 발생한다. 이 비동기 적용을 하지않는경우 스크립트의 위치가 head에있다면 먼저 script를 받기때문에 html 코드가 보이지않게되고 반대로 body에있다면 html은 어느정도읽히지만 script에 의존적이라면 html이 보여도 이상하게 나올수있다. 따라서 비동기적으로 처리가 필요하다. Async script 에 asyn src=\"\" 이런식으로asyn을 넣어주면 비동기적 처리를 실행하게된다. 장점 : 병렬 처리로 처리시간 감소 단점 : js에서 queryselect등의 작동이 불가해질수있다. 다운받아지는 시점에따라 기능이 어느정도 될지 예상 하기 힘듬 defer script defer src=\"\" 식으로 선언하고 html을 parsing 하는 과정에 병렬로 script를 다운받고 다 받아지면 실행하게 된다. 또한 순서에있이서도 차이가 있는데async의 경우 1,2,3 script 순서로 의존적이라하면 먼저 받아진 순서가 달라서 실행과정에서 꼬일수있지만defer같은경우는 순서에따라서 받아지고 순서에따라 실행됨 오늘 vue에서도 router의 모든 컴포넌트에 적용하니까 정말 체감이 많이된다.","link":"/2021/08/01/AsyncVsDefer/"},{"title":"Day59_Vue_Slot","text":"59일차 수업","link":"/2021/08/04/Day59-Vue-Slot/"},{"title":"Day60_Vuetify_dialog","text":"60일차 수업 vuetify 든 어떤 기능을 쓸때 api보고 코드 복붙하면 편하지만 어느정도 동작은 알고있어야된다.","link":"/2021/08/03/Day60-Vuetify-Dialog/"},{"title":"Day61-vuetify-table","text":"61일차 수업 Vuetify는 다 공식문서에 기능을 보고 구현하는 것뿐이다.Vuetify 기능을 설정부터 build 까지 정리해서, 수업은 설명보다 기능 코드만 정리하고자세한 구조는 따로 정리하는게 나을듯하다.","link":"/2021/08/04/Day61-Vuetify-Table/"},{"title":"JPA-기초-2-배경","text":"패러다임의 불일치 해결 JPA ORM 여태 DB중심의 SQL과 자바의 객체지향언어사이에서의 패러다임 불일치로 인해일일히 쿼리를 작성해서 객체지향과 다른방향이 발생했다.우리가 컬렉션 프레임워크를 사용하듯 객체지향적으로 데이터를 저장,로드 할 수있도록 만들어주는것이 JPAJPA가 쿼리를 작성함으로써 우리가 직접 쿼리를 작성하는 것을 줄여준다.","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-1-%EB%B0%B0%EA%B2%BD/"},{"title":"Day62-JPA-Save","text":"61일차 수업 JPA는 편하고 좋은데 코드 쓸게 없어서 허전하다.JDBCTEMPLATE으로 구성할떄보다 확실히 코드는 간결하다.","link":"/2021/08/04/Day62-JPA-Save/"},{"title":"JPA-기초-4-복합키 어노테이션","text":"복합키 어노테이션 (pk 여러개설정시)실제 비즈니스 로직에서는 pk값 사용시 꼬일수있다. (그래서 auto_increment ,sequence 같은 값을 사용)예를 예전에 주민번호를 pk값으로 설정했다고한다.근데 개인정보보호법으로 db에 저장불가로 둠 과 동시에 모든 pk값을 바꾸게된다.@IdClass@EmbeddedId@Embeddable@MapsId 출처: https://www.youtube.com/watch?v=0zTtkIYMOIw[토크ON세미나] JPA 프로그래밍 기본기 다지기 5강 - 양방향 매핑 | T아카데미","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-4-%EB%B3%B5%ED%95%A9%ED%82%A4-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98/"},{"title":"첫글","text":"공부가 끝이없어 지나치게 많아","link":"/2021/07/30/First-Content/"},{"title":"JPA-기초-5-JPA내부구조","text":"엔티티 매니저 요청이 올 때마다 스레드가 생성되서는 처리함. 영속성 컨텍스트 (=엔티티 매니저)JPA를 이해하는데 중요한 용어엔티티를 영구 저장하는 환경이라는 뜻EntityManager.persist(entity) 엔티티매니저가 영속성 컨텍스트(눈에 보이지않는 영역) 스프링프레임워크 같은 컨테이너환경 (엔티티 매니저를 주입 받아서 사용가능)엔티티매니저 N : 영속성 컨텍스트 1 - N:1관계만약 a,b,c서비스가 같은 트랜잭션이면 같은 영속성 컨텍스트 접근 엔티티의 생명주기비영속영속성 컨텍스트와 전혀관계가 없는 상태예)생각해보면 프로젝트할때 실수로 set만 해놓고 .save() 빼먹으면 저장이되지않았다. - 이것을 비영속 상태라고한다. JPA와 관계가없다. 영속영속성 컨텍스트에 저장된 상태 EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); //미리 멤버객체를 만들고 set한 가정 em.persist(member) - 객체를 저장환 상태 (영속) 준영속영속석 컨텍스트에 저장되었다가 분리된 상태 - 값이 변해도 더이상 db 반영이 되지않는다. em.detach(member); em.clear() em.close() 삭제삭제된 상태 em.remove(member0; 왜 이런 비영속,준영속이있나? 영속성컨텍스트의 이점 엔티티 조회, 1차 캐시영속컨텍스트 안에는 여러 기능이있는데 이중 1차캐시라는것이 존재한다.영속컨텍스트가 존재할때만 잠깐 있는 것 내부 메모리공간 정도 여기서 조회하게되면 db로 가는게 아니라 1차캐시를 찾고 db로 이동하게됨 (한개의 트랜잭션에서 잠깐 발생됨 따라서 공유X)그리고 db에서 찾게되도 1차캐시로 저장하고 반환됨 따라서 동일성보장 Member a = em.find(Member.class, &quot;member1&quot;); member b = em.find(Memeber.class, &quot;member1&quot;); a == b true 1차캐시내에서 같은 레퍼런스를 물고있는거다. 트랜잭션을 지원하는 쓰기 지연 (버퍼기능) transaction.begin(); em.persist(memberA); -1차캐시저장 sql만 생성 em.persist(memberB); -1차캐시저장 sql만 생성 // 아직 DB insert X transaction.commit(); 커밋하는 순간 insert쿼리 전송 (물론 쿼리문은 두번날아감) 쓰기지연을 보내는 sql쿼리를 보내는 과정을 flush라고 함 3강에서했던 캐시 전송(비운다기보다 DB와 sync) 썻던예제를 보면 flush,clear()에서 flushcommit은 (flush+commit기능) 변경감지 (우리가 update쿼리를 설정하지않는이유)조회후에set수정(update쿼리X)transaction.commit(); 사실 1차캐시 말고 1차캐시 생성시점에서 스냅샷이라는 것도 존재하는데 jpa를 flush하는 시점에 비교해서 바뀐부분이있으면 자동으로 update쿼리를 만든다오해하면안되는 부분 flush는 컨텍스트를 비우는것이아닌 db와 sync 하는 목적비우는것은 아까 clear()메서드다. flush의 경우에는em.flush() 직접호출트랜잭션 커밋 -commit + flushjpql 쿼리 실행 - 플로시 자동호출 ( 이부분이 em.setName(something1), em.setName(something2) 이 값 중간에 끼워져있다면자동으로 flush가 되고 jqpl쿼리가 실행되면서 flush 되버린다.이유: 만약에 jpql 쿼리의 flush가 연동되지않는다면 나중에 값이 조회되지않는 문제가 발생하기때문에 commit은 안됨 (실수방지 자동)그래서 mybatis 또는 jdbcTemplate의 경우 select값이 안나올수가있었는데 영속성 컨텍스트가 flush되지않아서 지연로딩에 관해(지연로딩을 하려면 영속성 컨텍스트가 살아있어야하는데 이는 컨트롤러로 나갈때 빠지게된다. LazyInitializationException따라서 한 트랜잭션이 끝나고 컨트롤러에서 lazy로딩시 오류 발생 - 준영속성 상태 해결- 준영속전에 미리 로딩하는 등의 방법)우리가 member만 조회하고싶을때 lazy 옵션을 적용했는데 이때 null Exception이 터지지않는 이유는 프록시로 조회됬기때문이다.가짜 값을 넣어주고 실제 조회할때 값을 가져오게된다. 가급적 지연로딩을 사용해야하는 이유연쇄적으로 작용을 방지하기위함 ( member에서 팀을 eager로 건다 근데 team에도 eager 걸려있다면 많은 sql이 작용하다 문제가 발생한다.)필요할때 fetch를 사용하면된다. 출처: https://www.youtube.com/watch?v=wt_BEqxjaj8[토크ON세미나] JPA 프로그래밍 기본기 다지기 7강 - JPA 객체지향쿼리 | T아카데미","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-5-JPA%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0/"},{"title":"JPA-기초-6-JPA객체지향쿼리","text":"JPQL가장 단순한 조회 방법 JPA를 사용하면 엔티티 객체를 중심으로 개발 (객체가 있다고 생각하고 DB 중심에서 벗어난 생각)하지만 특정 조건에있어서는 sql을 사용할 수 밖에는 없다. JPA는 SQL을 추상화한 JPAQL이라는 객체 지향 쿼리 언어를 제공SQL문법과 유사(SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN)지원 JPQL은 엔티티 객체를 대상으로 쿼리SQL은 데이터 베이스 테이블을 대상으로 쿼리 SQL을 추상화해서 특정 DB SQL에 의존 X (실제 쿼리를 보면 각 DB vendor 에 맞게 쿼리 작성후 날림) JPQL을 한마디로 정의하면 객체지향 SQL 예 ) String jpql = &quot;select m From Member m where m.name like '%hello%'&quot;; - 멤버 테이블이아닌 엔티티를 select 하는것, 별칭사용필수 List&lt;Member&gt; result = em.createQuery(jpql, Member.class).getResultList(); 결과 조회 API query.getResultList(): 결과가 하나 이상, 리스트 반환 query.getSingleResult(): 결과가 정확히 하나, 단일 객체 반환(하나 초과 인경우 예외 발생) 파라미터 바인딩이름 기준 SELECT m FROM Member m where m.username=:username query.setParameter(&quot;username&quot;, usernameParam); 위치 기준 SELECT m FROM Member m where m.username=?1 query.setParameter(1, usernameParam); 프로젝션 SELECT m FROM Member m -&gt; 엔티티 프로젝션 //멤버를 가져올때 멤버와 연관된 팀 가져오고싶을때 (팀 엔티티를 가져옴) SELECT m.team FROM Member m -&gt; 엔티티 프로젝션 //특정 엔티티 조회가 아닌 값을 가져옴 SELECT m.username, m.age FROM Member m -&gt; 단순 값 프로 젝션 //DTO로 조회 -&gt; new 명령어 SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m 페이징 API 두가지 setFirstResult(int starPosition) : 조회 시작 위치 (0부터시작) setMaxResults(int maxResult) : 조회할 데이터 수 예) 10번쨰부터 20개 가져오는 코드 (스프링에서는 이것조차 interface에서 전부 구현되있음) String jpql = &quot;select m from Member m order by m.name desc&quot;; List&lt;member&gt; resultList = em.createQuery(jpql, Member.class) .setFirstResult(10) .setMaxResults(20) .getResultList(); select COUNT(m), 회원수 SUM(m.age), 나이합 AVG(m.age), 평균나이 MAX(m.age), 최대 나이 MIN(m.age) 최소 나이 from Member m 조인 내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t 외부 조인: SELECT m FROM Member m LEFT [OUTER] JOIN m.team t 세타 조인: SELECT count(m) FROM Member m, Team t where m.username = t.name 페치 조인 lazy로딩 적용하고 필요할때 한번에 조회(이렇게 하면 물론 단면적으로보면 현재코드에서는 lazy로딩 적용 의미 없긴하다.)엔티티 객체 그래프를 한번에 조회하는 방법별칭을 사용할 수 없다. JPQL: select m from Member m join fetch m.team SQL: SELECT M.*, T.*FROM MEMBER T INNER JOIN TEAM T ON M.TEAM_ID=T.ID case식 가능 select case when m.age &lt;= then ‘학생요금’ when m.age &gt;= then ‘경로요금’ else ‘일반요금’ endfrom Member m 사용자 정의 함수 호출 가능Named 쿼리 - 어노테이션 가능 (로딩시점에 파싱되서 로딩시점에 오류 체크 가능) 출처: https://www.youtube.com/watch?v=PMNSeD25Qko[토크ON세미나] JPA 프로그래밍 기본기 다지기 6강 - JPA 내부구조 | T아카데미","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-6-JPA%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%BF%BC%EB%A6%AC/"},{"title":"JPA-기초-7-JPA_Spring_QueryDSL","text":"스프링 데이터 JPA우리가 현재 스프링부트에서 사용하는 JPA - 독일의 모 개발자em.persist() - save()em.find() - find() 이런것들이 구현된것이다. 우리가 CRUD를 했던 모든 코드가 인터페이스화 되서 적용된 산물로 보면 될 것 같다.인터페이스 상속을 통한 구현 JPAREPOSITORY&lt;타입, 식별자&gt; 이런식으로 사용 스프링에 로딩 시점에 구현체를 만들어서 각각의 레포가 적용됨 Spring Data Jpa —생성—-&gt; somethingRepo(구현 클래스) ——&gt; somthing 스프링 데이터-------------------(db 넣었다 빼는 기능) 기본기능들(CrudRepository) save(S) : S findOne(ID) : T exists(ID) : boolean count() : long delete(T)..... PaginAndSortingRepository findAll(Sort) : Iterable&lt;T&gt; findAll(Pagealbe) : page&lt;T&gt; 다양한 API가 있지만 그중에서 2개 정렬 기능 public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { List&lt;Member&gt; findByName(String username, Sort sort); } SELECT * FROM MEMBER M WHERE M.NAME = 'hello' ORDER BY AGE DESC 페이징기능 controller쪽에서 Page&lt;somthing&gt; PaageRequest pageRequest = new PageRequest(1, 10); 현재페이지1 부터 10개 repository.findByName(&quot;somthing&quot;, pageRequest); repository public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { Page&lt;Member&gt; findByName (String username, Pagealbe pagealbe); } 스프링 데이터------------------- 스프링 데이터 JPA-------------------(기본으로 공통 JPA기능) JpaRepsitory (jpa공통 기능) findAll() : List&lt;T&gt; findAll(Sort) : List&lt;T&gt; findAll(Iteralbe&lt;ID&gt;) : List&lt;T&gt; save(Iterable&lt;S&gt;) : List&lt;S&gt; flush............ 스프링 데이터 JPA------------------- named 쿼리 어노테이션 처럼우리가 스프링 부트 실행시 Jparepository의 쿼리문을 파싱하는데 이때 문법오류를 알아서 걸러준다. 프로젝트하면서 jpa레포에서 쿼리 실수하면 났었던 그 오류인것같다. 확실히 좋은것같다. - QueryDSL문자가 아닌 코드로 작성컴파일 시점에 문법 오류 발견코드 자동완성코드모양이 JPQL과 거의 비슷동적 쿼리 - 가장 큰 장점jpql문법 전부 지원해줌 JPAQueryFactory query = new JPAQueryFactory(em);QMember m = QMember.member; List hello = query.selectFrom(m).where(m.age.gt(18).and(m.name.contains(“hello”))).orderBy(m.age.desc()).fetch(); queryDSL로 한번 wrap하였다.queryDSL이 자바코드로 jpql을 generate 해준다. 쿼리로 실수할 일이없다. 실행할필요없이 오류를 자동완성되고 오류를 잡아주는 장점이있다.가장큰 장점JPQL을 문자열을 더하지만 QueryDSL은 동적쿼리를 작성해서 자바코드처럼 작성가능 String name = “member”;int age = 9; QMember m = QMember.member; BooleanBuilder builder = new BooleanBuilder();if (name != null) { builder.and(m.name.contains(name));}if (age != 0) { builder.and(m.age.gt(age);} List list =query.selectFrom(m).where(builder).fetch(); 그렇기때문에 리팩토링 (공통적인부분 메서드로) 가독성 모든 부분에서 자바처럼 코드를 짤수있다.쿼리지만 자바코드로 해결이가능한점. 느낀점:강의를 듣는데 빨려들어갔다.양심있으면 책사야된다 이미샀지만. 책을 사서 공부하지만 역시 강의로 듣는건 다르다.특히 마지막에 QueryDSL은 무조건 습득하겠다.이제 JPA 튜토리얼 끝이다.이제 적용하면서 습득하면 될 것 같다. 출처: https://www.youtube.com/watch?v=gRqyzi9VGYc[토크ON세미나] JPA 프로그래밍 기본기 다지기 8강 - Spring Data JPA와 QueryDSL 이해 | T아카데미","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-7-JPA-Spring-QueryDSL/"},{"title":"JPA-기초-2-단방향매핑","text":"아래는 각 객체간의 연관관계가 없이 두번 조회를 통해 값을 알아내는 방법이다.구조는 다음과 같다. @Entity public class Memeber { @Id @GeneratedValue private Long id; @Column(name = &quot;USERNAME&quot;) private String name; private int age; @Column(name = &quot;TEAM_ID&quot; private Long teamId; } @Entity public class Team { @Id @GeneratedValue private Long id; private String name; } 저장시 다음과같이 팩토리, 매니저 생성(팩토리의경우는 비용이 크지만 매니저의 경우 비용이 적다) - 자바 ORM 표준 JPA프로그래밍 EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;hello&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); 팀저장 Team team = new Team(); team.setName(&quot;TeamA&quot;); em.persist(team); 멤버저장 Member member = new Member(); member.setName(&quot;member1&quot;); member.setTeamId(team.getId()); &lt;- team id em.persist(member); 팀을 조회하기 위해서는 연관관계가 없기때문에 두번 조회가 필요하다. (엔티티 매니저를 통해서 접근)객체 지향적인 방법은 아니다. (토이프로젝트 진행시 JPA를 사용할줄 몰라서 이런식으로 사용했었다.)왜냐면 객체를 DB중심적으로 설계됐기때문이다. 객체중심적이었다면 접근 방식이 당연히 다르다. 조회 하는 순서 2번1번Member findMember = em.find(Member.class, member.getId());Long teamId = findMember.getTeamId(); 2번 연관관계가없다. Team findTeam = em.find(Team.class, team.getId()); em.find(Team.class, teamId); 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력관계를 만들수없다는 문제가 존재한다. 본격적인 연관관계 매핑 단방향 매핑Member -&gt; TeamMember는 Team을 참조할수있다. @Entity public class Memeber { @Id @GeneratedValue private Long id; @Column(name = &quot;USERNAME&quot;) private String name; private int age; 아래부분을 수정한다. // @Column(name = &quot;TEAM_ID&quot; // private Long teamId; 다음과같이 team 객체를 넣어준다. 하나의 팀이 여러 멤버를 갖기때문에 ManyToOne (멤버 입장에서 생각했을때 다대일관계) @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; } 위와같이 설계했을때 객체 지향적 모델링이 된다Member의 team 객체가 team_id(FK) 와 매핑이 된다. 저장방식 팀 Team team = new Team(); team.setName(&quot;TeamA:)' em.persist(team); 회원 Member member = new Member(); member.setName(&quot;member1&quot;); member.setTeam(team); //그냥 객체 그대로 넣어버리면된다. em.persist(member); 조회시 (참조연관관계로 조회 - 객체 그래프 탐색) Member findMember = em.find(Member.class, member.getId()); Team findTeam= findMember.getTeam(); jpa는 내부에 캐싱이되서 만약 select 쿼리를 보고싶으면 em.flush(); db쿼리를 보내준다.(뒤에 나오지만 비우는게아니다. 쓰기지연을 한번에 보내준다.) em.clear(); cash를 비운다. 또한 기본값이 join이기때문에 member만 가져오고 싶다면 fetch옵션을 lazy로 두면 된다. 기본값이 EAGER @ManyToOne(fetch = FetchType.LAZY) 출처: https://www.youtube.com/watch?v=bEtTpCviSc4[토크ON세미나] JPA 프로그래밍 기본기 다지기 4강 - 연관관계 매핑 | T아카데미","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-2-%EB%8B%A8%EB%B0%A9%ED%96%A5%EB%A7%A4%ED%95%91/"},{"title":"JS많이 쓰는 문법위주로 정리","text":"문법대해서 필요한 부분만 빠르게 정리해봤다. Vanilla JS서 주 사용 (쓸일은 없겠지만)‘use strict’ : 최상단에 추가해 정의되지않은 변수, 상수의 오류를 보여줌 블럭: 블럭으로 지역변수 느낌으로 선언 가능: {} 블럭 밖에 선언은 global 선언 말그대로 메모리에 위치해있음 필요할때만 사용변수 var VS let의 차이에서 var가 블럭안에 있음에도 블럭밖에서 잡힌다. (ES6 이후 let 지원) var VS let 호이스팅 여부 (선언하기전에 사용) let의 경우는 오류가 나오지만 var의 경우는 undefined로 나옴 또한 {}을 무시하기때문에 외부에서 사용 가능 global 선언이 되버린다. 그래서 let을 사용해야한다. JS는 data type 없음 number로 메모리 할당여부를 고려하지않는다. (자바나 C와 다르게 고려할 필요가 없음) first-class function 이말은 function 데이터 타입처럼 변수에 할당이 가능 즉 function(function) 이런식으로 자바에서 매개변수로 메서드를 받지못했었는데 JS는 가능하다. 또한 return 타입으로 function도 가능하다. `(백틱): String + value 우리가 흔히 String + data = stringdata 이런식으로 사용을많이하는데 JS에서는 template literals라고 백틱을 통해 `string ${data}`= stringdata 이런식으로 사용가능하다. (space도 다 자동 인식) type of : 데이터 타입 알림 Symbol: 고유 식별자로 사용가능 같은 Symbol 만들기 Symbol.for('') Symbol출력 Symbol.description을 사용해서 출력 (참고로 인스턴스 주소값을 가지고있어서 symbol의 이름이 XX라고해서 String XX와는 절대 같을수 없다.) String에서 ' 표시 consolelog(\"somting's stuff\") 이러면 somthing 이렇게만 나온다 consolelog(\"somting\\'s stuff\") 이런식으로 해야지 정상출력 또한 자바처럼 \\n로 줄바꿈 가능 equality stirng 5 === number 5 = > false string 5 == number 5 => true 매개변수 디폴트값 설정 여태 이런식으로 코드를 구성했는데 function showMessage(message, from) { if(from === undefined) { from = \"unknown\"; } } 아래 문법을 사용하면 default 값을 설정할수있다. function showMessage(message, from = \"unknown\") { 이렇게 하면 = 뒤에 값이 디폴트 값이됨 ...: ...args 배열형태로 전달 Arrow functioin 자바의 람다와같이 익명 function (reuturn 생략 function, name 생략가능) (자바에서는 매개변수있으면 return 생략안됐음) ex) cont somthing = () =&gt; console.log(‘todo’);const add = (a,b) =&gt; a+b 블록({})을 사용할경우에는 return을 사용한다.const somthing = (a,b) =&gt; { return somtihngtodo} 출처는 드림코딩 by 엘리 강의를 보고 정리했다.","link":"/2021/08/01/JS%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/"},{"title":"JS클래스","text":"JS에서도 클래스가 가능하다.———–클래스 선언————constructor(name,age) {this.name = namethis.age = age}speak() {console.log(${this.name}: Hello!);}} ———–인스턴스 생성———— const ree = new PerSon(‘ree’,28);console.log(ree.name)console.log(ree.age)ree.speak(); ———–Static사용 예———— Class Article { static publisher = “coding”;}const article = new Article(); console.log(Article.publisher) Oconsole.log(article.publisher) X static : Object마다 할당X 클래스 자체에 있음 ———–상속가능(Interitance)———— class Shape {constructor(width, height, color) {this.width = width;this.heigth = height;}getArea() {return width * this.heigth;}}class Recteangle extends Shape {} const rectangle = new Rectangle( 20, 20);rectangle.getArea(); instance of 도있다. 자바랑 매우 비슷하다. 출처는 드림코딩 by 엘리 강의를 보고 정리했다.","link":"/2021/08/01/JS%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"Vuex","text":"중앙관리가 필요한이유 vue를 쓰다보면 단순히 부모와 자식이 하나씩있으면 간단하지만 같은 todo앱을 만들때도 컴포넌트를 엄청사용해서 emit,props를 쓸때와 vuex를 쓸때는 시간도 그렇고 코드를 보기도 편했다. 자식의 자식이 연달아 있다면 계속 emit을 올려주거나 props를 연달아 받게된다. 그런 문제를 해결하기 위해서 v-bind=$attr, v-on=$listener를 사용하는 방법도있지만 store를 통해 관리해주는 vuex가 있다. 구조 vuex를 보자면 vuex의 구조는 state, mutations, actions, getters, mutationstype이있다. 여기서 state는 임계영역 데이터라고 보고, mutations는 동기화를 시키는영역 component에는 딱히 비교할만한게없다. actions는 비동기영역으로 메서드라고 보면되고 getters는 computed같은 흐름으로 보면된다 또한 actions는 비동기적이기때문에 동기작업이 필요한경우는 꼭 mutations에 넣어두고 서버로부터 요청이오는데 걸리는 시간때문에actions는 비동기 처리를하면서 다른 작업을 할 수 있는것이다. 요청이 만료되었을때 비로소 mutations에 데이터 commit이 되고 데이터 접근이 가능한 순서 actions => mutations => state Actions vuex는 처음에 actions에 context라는 object를 넣는다. 그다음으로 입력받은 payload (context, payload) 구조 ---> actions로 넘길때 this.$store.dispatch (action이름, value) ---> mustations로 commit할때 this.$store.commit() addtodo( {commit, dispatch ….등이 있음}, value)context 안에는 다음과같이 commit, dispatch….같은 다양한 기능이있음actions에서 비동기가 일어나는 기능 axios , seTimeout….등 처리일단 비동기한후에 commit처리 (mutations) ex) actions: { addTodo( {commit}, value) {//또는 axios.post() 서버에 요청 작업// setTimeout으로 2초후에 commit하는 작업 등 setTimeout(function() { commit(‘ADD_TODO’, value); }, 2000); } }, payload는 많이들 데이터를 통 느낌으로 보낼때 단일 value가 아닌 배열식일때 사용한다. convention같은것 &lt;더미데이터&gt;https://jsonplaceholder.typicode.com/ 에서 더미데이터를 요청해서 받을수있다. 서버가 따로 없다면 이것을 이용해서 axios사용 axios promise가 리턴됨 (비동기)그래서 만약 axios.get(‘https://jsonplaceholder.typicode.com/users').then(res =&gt; {}이런식 요청하면요청을 보내고 promise를 리턴해준다. axios요청을 보내놓고 밑에 작업을한다. 그뒤에 res 결과가 오면 res =&gt; {}에 {}가 실행됨 ex) 다음과같이 된다면 axios.get(‘https://jsonplaceholder.typicode.com/users').then(res =&gt; { console.log(res); }) const a = 1; console.log(a); }아마 서버요청한뒤에 응답을기다리는게 아니라 바로 console.log(a)를찍고 그뒤에 res가 출력될것이다. 사용할때 아래처럼 고려하면 편하다. state를 가져올때는 computed 안에 작성하도록한다. actions를 작성할때 vuex에서 어떤 context라는 object를 넣어준다. 이것만 기억하자commit 뮤테이션방향dispatch 액션방향 actionaddtodo(context, value}context안에 commit , dispatch 등등 여러개가있다. MAPHELPER impot { mapstate } from ‘vuex’ 구조 computed: mapstate,gettersmethods: mutations, mapActions가 들어간다. 관련된 로직끼리 묶어서 파일로 뺴내는 것을 modules이라한다.코드가 적은게 아니라면 사용하는게 맞다 -출처 코지코더를 보고 정리했다 -","link":"/2021/08/01/Vuex/"},{"title":"JPA-기초-3-양방향매핑","text":"——————-제일 중요한 부분————————– Member 에서도 Team 접근하고 Team에서도 Member접근하도록하는것 보면 DB의 경우는 객체 처럼 member.team 또는 team.member가아닌 다 접근이 가능하다. 멤버의 경우 단방향 매핑이 둘다 있는 것과 같다. @Entity public class Memeber { @Id @GeneratedValue private Long id; @Column(name = &quot;USERNAME&quot;) private String name; private int age; @ManyToOne @JoinColumn(name = &quot;TEAM_ID&quot;) private Team team; } 팀의 경우 매핑이 다르다. Team 엔티티는 컬렉션 추가 @Entity public class Team { @Id @GenerateValue private Long id; private String name; @OneToMany(mappedBy = &quot;team&quot;) List&lt;Memeber&gt; members = new ArrayList&lt;Member&gt;(); } 조회 Team findTeam = em.find(Team.class, team.getId()); int memberSize = findTeam.getMembers().size(); 역방향조회 왜 @OneTomay만 적으면 될것같은데 mappedBy라는 옵션이 추가되었는가 ————mappedBy란?—————만약에 현재 Member에다가 team을 set하는게 아니라 Team에다가 member를 set하는경우도 업데이트가 될것이다.이부분에서 누가 주인인지 지정해야할 필요가있다. 둘중에 하나만이 업데이트 값을 쥘수있고 하나는 조회만 가능하게 하는 것.Member를 주인으로 정하면 member.setTeam하면 되고만약 Team을 주인으로 정하면 Member.team().getmembers.add() 하면 업데이트가 된다.둘다 동시에 넣으면 주인의 것 하나만 업데이트가 되게한다. 주인 지정 방법 mappedBy (mappedBy를 썼다는것 자체가 어딘가 매핑되었다는 소리 Joinculumn 없음 매핑이 되었을뿐)주인의 것만 영향을 주지 mappedBy를 사용한 부분은 db업데이트의 영향을 미치지않는다 조회용으로 사용하겠다는 의미 결론: 테이블과 다르게 객체에서는 누가 연관관계 주인인지 정할필요가 있다. 주인만 업데이트가능하다.하지만 객체지향적으로는 양쪽 team과 Member 모두 set,add 해줄 필요가있다. 그럼 누구를 주인으로 정하나?외래키가 있는 곳을 주인으로 정하는 것. (사실 케바케지만 일반적으로 인지부조화문제때문) Member: 현재 외래키 갖고있음Team: PK = FK이유: 분명 Team을 업데이트 했는데 Member가 업데이트쿼리가 날라감 (혼란) 어지간해서는 단방향 필요할때 양방향으로 설정 객체 연관관계회원 -&gt; 팀 (단방향)팀 -&gt; 회원 (단방향) 테이블회원 &lt;-&gt; 팀 (양방향) 객체는 사실 양방향 관계가 아니라 서로다른 단방향이 2개다. (양방향처럼 보이는것 뿐)테이블은 외래키 하나로 두테이블을 관리 가능다음과같이 SELECT * FROM MEMBER M JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID SELECT * FROM TEAM T JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID 주인관계를 잘 모를때 실수하는 부분(현재 mappedBy가 team) Team team = new Team();team.setName(“TeamA”); em.persist(team); Member member = new Member();member.setname(“member1”); 역방향으로 업데이트 설정 (잘못된 예)team.getMembers().add(member); 주인에서 업데이트(올바른 예)member.setTeam(team);em.persist(member); 위와같이 실행한 경우 당연 업데이트 되지않음 출처: https://www.youtube.com/watch?v=bEtTpCviSc4[토크ON세미나] JPA 프로그래밍 기본기 다지기 4강 - 연관관계 매핑 | T아카데미 출처: https://www.youtube.com/watch?v=0zTtkIYMOIw[토크ON세미나] JPA 프로그래밍 기본기 다지기 5강 - 양방향 매핑 | T아카데미","link":"/2021/08/24/JPA-%EA%B8%B0%EC%B4%88-3-%EC%96%91%EB%B0%A9%ED%96%A5%EB%A7%A4%ED%95%91/"},{"title":"10_Authority","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/10_Authority/"},{"title":"0Security_Setting","text":"","link":"/2021/09/11/0_Security-Setting/"},{"title":"11_ExceptionTranslationFilter_RequestCacheAwareFilter","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/11_ExceptionTranslationFilter_RequestCacheAwareFilter/"},{"title":"12_Csrf","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/12_Csrf%20copy/"},{"title":"13_DelegatingProxyChain_FilterChainProxy","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/13_DelegatingProxyChain_FilterChainProxy/"},{"title":"14_SecurityFilterChains","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/14_SecurityFilterChains/"},{"title":"16_SecurityContextHolder_SecurityContext","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/16_SecurityContextHolder_SecurityContext/"},{"title":"15_Authentication","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/15_Authentication/"},{"title":"17_SecurityContextPersistenceFilter","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/17_SecurityContextPersistenceFilter/"},{"title":"18_Authentication Flow","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/18_Authentication%20Flow/"},{"title":"19_AuthenticationManager","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/19_AuthenticationManager/"},{"title":"1_UserCustom","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/1_UserCustom-2/"},{"title":"20_Authorization_ilterSecurityInterceptor","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/20_Authorization_ilterSecurityInterceptor/"},{"title":"21_FlowChart","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/21_FlowChart_22/"},{"title":"2_FormLogin","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/2_FormLogin/"},{"title":"3_UsernamePasswordAuthnticationFilter","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/3_UsernamePasswordAuthnticationFilter/"},{"title":"4_LogoutFilter","text":"","link":"/2021/09/11/4_LogoutFilter/"},{"title":"5_RememberMe","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/5_RememberMe/"},{"title":"6_RemebeMeFilter","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/6_RemebeMeFilter/"},{"title":"7_AnonymousFilter","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/7_AnonymousFilter/"},{"title":"8_SessionProtect","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/8_SessionProtect/"},{"title":"9_SessionManagementFilter","text":"출처: https://www.inflearn.com/course/%EC%BD%94%EC%96%B4-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0/dashboard","link":"/2021/09/11/9_SessionManagementFilter/"},{"title":"scproject_1_passwordEncoding_type","text":"","link":"/2021/09/28/Security_Project_1/"},{"title":"scproject_2_webIgnore","text":"","link":"/2021/09/28/Security_Project_2/"},{"title":"scproject_3_DB연동인증처리","text":"","link":"/2021/09/28/Security_Project_3/"},{"title":"scproject_4_인증부가기능_secretkey","text":"","link":"/2021/09/28/Security_Project_4/"},{"title":"scproject_5_successHandler","text":"","link":"/2021/09/28/Security_Project_5/"},{"title":"scproject_6_인증인가실패","text":"","link":"/2021/09/28/Security_Project_6/"},{"title":"scproject_7_ajax인증흐름","text":"","link":"/2021/09/28/Security_Project_7/"},{"title":"scproject_8_ajax인증필터흐름","text":"물론 설정에서 before로 기본필터인 User인증필터 앞에 두어야한다.","link":"/2021/09/28/Security_Project_8/"},{"title":"scproject_9_ajax인증필터","text":"","link":"/2021/09/28/Security_Project_9/"},{"title":"scproject_10_인증인가핸들러","text":"","link":"/2021/09/28/Security_Project_10/"},{"title":"scproject_11_인증인가예외","text":"","link":"/2021/09/28/Security_Project_11/"},{"title":"scproject_12_AjaxCustomDsl","text":"이부분에대해서는 자세히 다루지 않겠다 인프런 정수원 선생님 강의에서도 동적으로 메서드를 보안 설정하는 부분이있는데 오류가 좀 있기 때문이다.","link":"/2021/09/28/Security_Project_12/"},{"title":"scproject_13_Method보안설정","text":"","link":"/2021/09/28/Security_Project_13/"},{"title":"python_kakao_API_1(setting)","text":"카카오개발자 사이트접속 애플리케이션등록 사용하고자하는 애플리케이션 선택 카톡메시지를 받기위한 기본 권한설정 (잘못하면 AccessDenied 발생할수있음) 다음과 같이 대략적으로 사용용도만 적어서 적용한다. 로그인에서 다음과같이 설정 사용하고자하는 플랫폼 (web만 연동하기에)","link":"/2021/09/29/python-kakao-API-1/"},{"title":"python_kakao_API_2(카톡받기))","text":"카카오개발자 사이트접속 애플리케이션등록 사용하고자하는 애플리케이션 선택 카톡메시지를 받기위한 요청보내기 다음과같이 요청을 보낸다. 로그인 요청 그러면 동의화면 출력후 다음으로 넘어간다(시간이걸림) 이런식으로 리다이렉트 되면서 특정 코드값을 보내준다.(일정 시간 내에 해야됨)https://localhost.com/?code={code} 토큰, api키는 노출되지않도록 주의 (다음과 같이 요청시 액세스토큰, 리프레쉬토큰을 보내준다.) 토큰 파일로 저장하는 과정과 리프레쉬 과정 저장된 파일 최종적으로 메시지를 받기위한 과정 최종적으로 받은 알림","link":"/2021/09/29/python-kakao-API-2/"},{"title":"python_Flask_vue","text":"/member/ 부분을보면 id가 파라미터부분이다.@Param 처럼 특정정보를 가변인자로 받을 수 있다. 일반적으로 boot에서 main 애플리케이션처럼 app.run()의 코드가 유사하다. GET, POST 매핑방법 다른서버의 요청이기때문에 Cors 설정은 필수다.(설정방법은 다음과 같다 -&gt; /login) Vue에서는 설정한 부분은 없다. (간단한 예제)","link":"/2021/09/29/python-Flask-vue/"},{"title":"python-random_2","text":"","link":"/2021/09/30/python-random_2/"},{"title":"python_calc_1","text":"","link":"/2021/09/30/python-calc_1/"},{"title":"python_sentence_3","text":"","link":"/2021/09/30/python-sentence_3/"},{"title":"python-slicing_4","text":"","link":"/2021/09/30/python-slicing_4/"},{"title":"python_strMethod_5","text":"","link":"/2021/09/30/python-strMethod_5/"},{"title":"python_strFormat_6","text":"","link":"/2021/10/01/python-strFormat-6/"},{"title":"python_list_7","text":"","link":"/2021/10/01/python-strFormat-7/"},{"title":"python_dict_8","text":"","link":"/2021/10/01/python-dict_8/"},{"title":"python_set_9","text":"","link":"/2021/10/01/python-set_9/"},{"title":"python_dataType_10","text":"list, dict, set의 차이 1. 사용가능한 메서드가 차이난다. 2. 타입이 다르다. 3. dict의 경우 키, 밸류가 존재한다. 사용가능한 메서드 dict : keys, values, get, update, pop, clear .. list : append, index, pop, extend, insert .. set : 집합개념 union, add, intersection, dieffernce ..","link":"/2021/10/01/python-dataType_10/"},{"title":"python_for_while_11","text":"","link":"/2021/10/08/python-for-while_11/"},{"title":"python-method-12","text":"","link":"/2021/10/10/python-method-12/"},{"title":"python-sys-io_13","text":"","link":"/2021/10/10/python-sys-io_13/"},{"title":"python-db_myql","text":"","link":"/2021/10/11/python-db_mysql/"},{"title":"MySql_2_연산자","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/13/MySql_basic_2_operator/"},{"title":"MySql_기초_1","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/12/MySql_basic_1_start/"},{"title":"MySql_3_boolean","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/13/MySql_basic_3_boolean/"},{"title":"MySql_4_between","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/13/MySql_basic_4_between/"},{"title":"MySql_5_IN","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_5_In/"},{"title":"MySql_6_LIKE","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_6_like/"},{"title":"MySql_7_ROUND,CEIL,FLOOR","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_7_round_ceil_floor/"},{"title":"MySql_8_GREATEST,LEAST","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_8_greatest_least/"},{"title":"MySql_9_MATH","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_9_math/"},{"title":"MySql_10_TRUNCATE","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_10_truncate/"},{"title":"MySql_11_STR","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_11_str/"},{"title":"MySql_12_date_time","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_12_date_time/"},{"title":"MySql_13_IF_CASE_IFNULL","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_13_etc/"},{"title":"MySql_14_GROUPBY","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_14_groupby/"},{"title":"MySql_15_HAVING","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_15_having/"},{"title":"MySql_16_DISTINCT","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_16_distinct/"},{"title":"MySql_17_SUBQUERY","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_17_subquery/"},{"title":"MySql_18_JOIN","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_18_join/"},{"title":"MySql_19_SET","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_19_set/"},{"title":"MySql_20_SETTING","text":"CLI는 어느정도 익숙하기때문에GUI형태인 workbench로 사용해보도록한다. 출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_20_setting/"},{"title":"MySql_21_ALTERTABLE","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_21_altertable/"},{"title":"MySql_22_INSERT","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_22_insert/"},{"title":"MySql_23_CONSTRAINT","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_23_constraint/"},{"title":"MySql_25_DATE_TIME","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_25_date_time/"},{"title":"MySql_24_DECIMAL","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_24_decimal/"},{"title":"MySql_26_UPDATE","text":"출처 얄코 : https://www.youtube.com/watch?v=dgpBXNa9vJc&amp;t=3883s","link":"/2021/10/14/MySql_basic_26_update/"},{"title":"Security_Context_저장방식","text":"","link":"/2021/10/15/SecurityContext/"},{"title":"Oauth2_DefaultOAuth2UserService","text":"기본적으로 oauth2도 다른 세션,jwt와 같이 userDetail서비스에 해당하는 클래스가있어서resource서버으로부터 받은 데이터로 loadUser에서 값을 처리한다.null값 체크후에 문제가 없다면 processOauth2User메서드로 이동하게되고 이 메서드에서 oauth로 받은계정이이전과 같이다른경우( ex)구글계정프로필이업데이트된경우 ) 그에따른 업데이트를 진행위와같이 각 provider별로 나눠져있다. 제공하는 attribute가 다르기때문에 bs4쓰듯이 값을 찾아서 꺼내야한다.","link":"/2021/10/19/Oauth2/"},{"title":"Security_Jwt_Config","text":"","link":"/2021/10/23/Security_Jwt_config/"},{"title":"Security_jwt_debug","text":"","link":"/2021/10/26/debug/Security_jwt_debug/"},{"title":"Security_Jwt_암호화의 필요성","text":"","link":"/2021/10/26/Security_Jwt_CS/"},{"title":"if __name__ &#x3D;&#x3D; &quot;__main__&quot;","text":"","link":"/2021/10/26/python-name__main__/"},{"title":"python-crawling_thread","text":"","link":"/2021/10/28/python-crawling_thread/"},{"title":"서버요청시_Security_context","text":"","link":"/2021/10/31/project_kh_team/Project_securityContext/"},{"title":"Vue_익명객체내부에서전역변수접근하기","text":"$ref 같은경우에는 팀원분이 찾은 방안이고 전역변수는 내가 찾았다.매번 그냥 지나쳤던 개념인데 감사하다. 이 모든게 기초가 부족해서다.","link":"/2021/11/03/debug/Vue_ref/"},{"title":"spring_batch_개요 - SpringBatch","text":"","link":"/2021/11/04/springbatch/1_Spring_batch/"},{"title":"JPA양방향에서주의할점","text":"","link":"/2021/11/09/project_kh_team/JPA_1/"},{"title":"생성자빠진경우오류","text":"","link":"/2021/11/10/debug/etc_1/"},{"title":"ManyToOne영속성전이","text":"","link":"/2021/11/10/debug/etc_2/"}],"tags":[{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"SpringSecurity","slug":"SpringSecurity","link":"/tags/SpringSecurity/"},{"name":"Lecture","slug":"Lecture","link":"/tags/Lecture/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"SpringSecurity_project","slug":"SpringSecurity-project","link":"/tags/SpringSecurity-project/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"Springboot","slug":"Springboot","link":"/tags/Springboot/"}],"categories":[{"name":"JPA","slug":"JPA","link":"/categories/JPA/"},{"name":"SpringSecurity","slug":"SpringSecurity","link":"/categories/SpringSecurity/"},{"name":"Lecture","slug":"Lecture","link":"/categories/Lecture/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"SpringSecurity_project","slug":"SpringSecurity-project","link":"/categories/SpringSecurity-project/"},{"name":"SpringSecurity","slug":"SpringSecurity-project/SpringSecurity","link":"/categories/SpringSecurity-project/SpringSecurity/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Flask","slug":"Python/Flask","link":"/categories/Python/Flask/"},{"name":"grammar","slug":"Python/grammar","link":"/categories/Python/grammar/"},{"name":"MySql","slug":"MySql","link":"/categories/MySql/"},{"name":"debug","slug":"debug","link":"/categories/debug/"},{"name":"SpringBatch","slug":"SpringBatch","link":"/categories/SpringBatch/"}]}