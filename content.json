{"pages":[],"posts":[{"title":"첫글","text":"공부가 끝이없어 지나치게 많아","link":"/2021/07/30/First-Content/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/29/hello-world/"},{"title":"AsyncVsDefer","text":"Async Vs Defer 비동기가 필요한 이유 html을 브라우저 읽을때 코드를 읽다 sciprt를 만나면 서버에서 다운받고 읽게된다. 이 방식이면 스크립트가 클수록 사용자가 기다리는 시간이 발생한다. 이 비동기 적용을 하지않는경우 스크립트의 위치가 head에있다면 먼저 script를 받기때문에 html 코드가 보이지않게되고 반대로 body에있다면 html은 어느정도읽히지만 script에 의존적이라면 html이 보여도 이상하게 나올수있다. 따라서 비동기적으로 처리가 필요하다. Async script 에 asyn src=\"\" 이런식으로asyn을 넣어주면 비동기적 처리를 실행하게된다. 장점 : 병렬 처리로 처리시간 감소 단점 : js에서 queryselect등의 작동이 불가해질수있다. 다운받아지는 시점에따라 기능이 어느정도 될지 예상 하기 힘듬 defer script defer src=\"\" 식으로 선언하고 html을 parsing 하는 과정에 병렬로 script를 다운받고 다 받아지면 실행하게 된다. 또한 순서에있이서도 차이가 있는데async의 경우 1,2,3 script 순서로 의존적이라하면 먼저 받아진 순서가 달라서 실행과정에서 꼬일수있지만defer같은경우는 순서에따라서 받아지고 순서에따라 실행됨 오늘 vue에서도 router의 모든 컴포넌트에 적용하니까 정말 체감이 많이된다.","link":"/2021/08/01/AsyncVsDefer/"},{"title":"JS많이 쓰는 문법위주로 정리","text":"문법대해서 필요한 부분만 빠르게 정리해봤다. Vanilla JS서 주 사용 (쓸일은 없겠지만)‘use strict’ : 최상단에 추가해 정의되지않은 변수, 상수의 오류를 보여줌 블럭: 블럭으로 지역변수 느낌으로 선언 가능: {} 블럭 밖에 선언은 global 선언 말그대로 메모리에 위치해있음 필요할때만 사용변수 var VS let의 차이에서 var가 블럭안에 있음에도 블럭밖에서 잡힌다. (ES6 이후 let 지원) var VS let 호이스팅 여부 (선언하기전에 사용) let의 경우는 오류가 나오지만 var의 경우는 undefined로 나옴 또한 {}을 무시하기때문에 외부에서 사용 가능 global 선언이 되버린다. 그래서 let을 사용해야한다. JS는 data type 없음 number로 메모리 할당여부를 고려하지않는다. (자바나 C와 다르게 고려할 필요가 없음) first-class function 이말은 function 데이터 타입처럼 변수에 할당이 가능 즉 function(function) 이런식으로 자바에서 매개변수로 메서드를 받지못했었는데 JS는 가능하다. 또한 return 타입으로 function도 가능하다. `(백틱): String + value 우리가 흔히 String + data = stringdata 이런식으로 사용을많이하는데 JS에서는 template literals라고 백틱을 통해 `string ${data}`= stringdata 이런식으로 사용가능하다. (space도 다 자동 인식) type of : 데이터 타입 알림 Symbol: 고유 식별자로 사용가능 같은 Symbol 만들기 Symbol.for('') Symbol출력 Symbol.description을 사용해서 출력 (참고로 인스턴스 주소값을 가지고있어서 symbol의 이름이 XX라고해서 String XX와는 절대 같을수 없다.) String에서 ' 표시 consolelog(\"somting's stuff\") 이러면 somthing 이렇게만 나온다 consolelog(\"somting\\'s stuff\") 이런식으로 해야지 정상출력 또한 자바처럼 \\n로 줄바꿈 가능 equality stirng 5 === number 5 = > false string 5 == number 5 => true 매개변수 디폴트값 설정 여태 이런식으로 코드를 구성했는데 function showMessage(message, from) { if(from === undefined) { from = \"unknown\"; } } 아래 문법을 사용하면 default 값을 설정할수있다. function showMessage(message, from = \"unknown\") { 이렇게 하면 = 뒤에 값이 디폴트 값이됨 ...: ...args 배열형태로 전달 Arrow functioin 자바의 람다와같이 익명 function (reuturn 생략 function, name 생략가능) (자바에서는 매개변수있으면 return 생략안됐음) ex) cont somthing = () =&gt; console.log(‘todo’);const add = (a,b) =&gt; a+b 블록({})을 사용할경우에는 return을 사용한다.const somthing = (a,b) =&gt; { return somtihngtodo} 출처는 드림코딩 by 엘리 강의를 보고 정리했다.","link":"/2021/08/01/JS%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/"},{"title":"JS클래스","text":"JS에서도 클래스가 가능하다.———–클래스 선언————constructor(name,age) {this.name = namethis.age = age}speak() {console.log(${this.name}: Hello!);}} ———–인스턴스 생성———— const ree = new PerSon(‘ree’,28);console.log(ree.name)console.log(ree.age)ree.speak(); ———–Static사용 예———— Class Article { static publisher = “coding”;}const article = new Article(); console.log(Article.publisher) Oconsole.log(article.publisher) X static : Object마다 할당X 클래스 자체에 있음 ———–상속가능(Interitance)———— class Shape {constructor(width, height, color) {this.width = width;this.heigth = height;}getArea() {return width * this.heigth;}}class Recteangle extends Shape {} const rectangle = new Rectangle( 20, 20);rectangle.getArea(); instance of 도있다. 자바랑 매우 비슷하다. 출처는 드림코딩 by 엘리 강의를 보고 정리했다.","link":"/2021/08/01/JS%ED%81%B4%EB%9E%98%EC%8A%A4/"}],"tags":[],"categories":[]}